"""
Вася решил передать Пете шифрограмму.
Поскольку о промышленных шифрах Вася ничего не знает,
он решил зашифровать сообщение следующим образом: он посылает Пете строку.

Каждый символ строки — либо буква, либо пробел, либо точка «.», либо две точки «..».
Если после какой-то буквы стоит точка, значит, мы оставляем букву без изменений
(об одной точке Вася задумался, чтобы усложнить расшифровку). Саму точку при этом надо удалить.
Если после какой-то буквы стоят две точки, то предыдущий символ надо стереть. Обе точки при этом тоже нужно удалить.
Возможна ситуация, когда сообщение после расшифровки будет пустым.
В качестве результата можно вернуть просто пустую строку.

Примеры шифровок-расшифровок:

абра-кадабра. → абра-кадабра
абраа..-кадабра → абра-кадабра
абраа..-.кадабра → абра-кадабра
абра--..кадабра → абра-кадабра
абрау...-кадабра → абра-кадабра (сначала срабатывает правило двух точек, потом правило одной точки)
абра........ → <пустая строка>
абр......a. → a
1..2.3 → 23
. → <пустая строка>
1....................... → <пустая строка>

Помогите Пете написать программу для расшифровки.
Напишите функцию decrypt, которая принимает на вход шифр в виде строки, а возвращает расшифрованное сообщение.

Программа должна работать через конвейер (pipe):

$ echo  ‘абраа..-.кадабра’ | python3 decrypt.py
абра-кадабра

Команда echo выводит текст (в стандартный поток вывода).
"""

import sys


def decrypt(encryption: str) -> str:
    result = []
    """
        Расшифровывает сообщение, закодированное следующим образом:

        - символ без точки после него сохраняется;
        - символ с одной точкой после него сохраняется, точка удаляется;
        - символ с двумя и более точками после него удаляется вместе с точками;
        - одиночные точки, не относящиеся к символу, игнорируются.

        :param encrypted_text: зашифрованная строка
        :return: расшифрованная строка
        """
    decrypted_chars: list[str] = []
    position: int = 0
    text_length: int = len(encryption)

    while position < text_length:
        current_char = encryption[position]

        # Точка сама по себе не является символом
        if current_char == '.':
            position += 1
            continue

        # Подсчитываем количество точек после символа
        dot_count: int = 0
        next_position: int = position + 1

        while next_position < text_length and encryption[next_position] == '.':
            dot_count += 1
            next_position += 1

        if dot_count < 2:
            decrypted_chars.append(current_char)

        position = next_position if dot_count > 0 else position + 1

    return ''.join(decrypted_chars)


if __name__ == '__main__':
    data: str = sys.stdin.read()
    decryption: str = decrypt(data)
    print(decryption)
